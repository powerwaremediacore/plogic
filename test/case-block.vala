/* -*- Mode: vala; indent-tabs-mode: t; c-basic-offset: 2; tab-width: 2 -*-  */
/*
 * Copyright (C) 2016 Daniel Espinosa <daniel.espinosa@pwmc.mx>
 */
using Plg;

public class PlogicTest.CaseBlock
{
	public static void add_funcs ()
	{
		Test.add_func ("/plogic/case/block-or/no-evaluation",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op = new Plg.GOr ();
			assert (op.enable);
			assert (op.name == "OR1");
			assert (b.operators.size == 0);
			b.add_operator (op);
			assert (b.operators.size == 1);
			var i1 = new Plg.GInput ();
			i1.name = "Input1";
			var i2 = new Plg.GInput ();
			i1.name = "Input2";
			op.inputs.set (i1.name, i1);
			op.inputs.set (i2.name, i2);
			assert (op.inputs.size == 2);
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (i1.state);
			assert (i1.enable);
			assert (i2.state);
			assert (i2.enable);
			assert (op.get_parent () != null);
			assert (op.get_parent ().name == "Block1");
			assert (op.output.state == false);
			i1.state = false;
			assert (i1.state == false);
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == false);
			i1.state = true;
			i2.state = false;
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == false);
			i1.state = false;
			i2.state = false;
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == false);
		});
		Test.add_func ("/plogic/case/block-or/connected",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op = new Plg.GOr ();
			assert (op.enable);
			assert (op.name == "OR1");
			assert (b.operators.size == 0);
			b.add_operator (op);
			assert (b.operators.size == 1);
			var i1 = new Plg.GInput ();
			i1.name = "Input1";
			var i2 = new Plg.GInput ();
			i1.name = "Input2";
			op.inputs.set (i1.name, i1);
			op.inputs.set (i2.name, i2);
			assert (op.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input2
			op.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			assert (b.connect_output_internal ("Output1","OR1","Output1"));
			assert (b.outputs.get ("Output1").internal_connection != null);
			assert (op.output.connections.size == 1);
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (b.outputs.get ("Output1").state == true);
			bi1.state = false;
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (b.outputs.get ("Output1").state == true);
			bi2.state = false;
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (op.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
		});
		Test.add_func ("/plogic/case/block-2or/connected",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			// OR1
			var op1 = new Plg.GOr ();
			assert (op1.enable);
			assert (op1.name == "OR1");
			assert (b.operators.size == 0);
			b.add_operator (op1);
			assert (b.operators.size == 1);
			var i11 = new Plg.GInput ();
			i11.name = "Input1";
			var i12 = new Plg.GInput ();
			i12.name = "Input2";
			op1.inputs.set (i11.name, i11);
			op1.inputs.set (i12.name, i12);
			assert (op1.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input2
			op1.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op1.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			assert (b.connect_output_internal ("Output1","OR1","Output1"));
			// add second OR
			var op2 = new GOr ();
			op2.name = "OR2";
			var i21 = new Plg.GInput ();
			i21.name = "Input1";
			var i22 = new Plg.GInput ();
			i22.name = "Input2";
			op2.inputs.set (i21.name, i21);
			op2.inputs.set (i22.name, i22);
			assert (op2.inputs.size == 2);
			op2.output.name = "Output2";
			assert (b.operators.size == 1);
			b.add_operator (op2);
			assert (b.operators.size == 2);
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b.inputs.set (bi3.name, bi3);
			assert (b.inputs.size == 3);
			assert (b.inputs.get ("Input3").state == true);
			var c4 = new GConnection ();
			c4.value = "Input3";
			op2.inputs.get ("Input2").connection = c4;
			var c5 = new GConnection ();
			c5.operator = "OR1";
			c5.value = "Output1";
			op2.inputs.get ("Input1").connection = c5; // Input1 = OR1.Input1
			var c5a = new GConnection ();
			c5a.operator = "OR2";
			c5a.value = "Input1";
			op1.output.connections.add (c5a);
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b.outputs.set (bo2.name, bo2);
			assert (b.connect_output_internal ("Output2","OR2","Output2"));
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi1.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi2.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi3.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == false);
		});
		Test.add_func ("/plogic/case/block-and/no-evaluation",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op = new Plg.GAnd ();
			assert (op.enable);
			assert (op.name == "AND1");
			assert (b.operators.size == 0);
			b.add_operator (op);
			assert (b.operators.size == 1);
			var i1 = new Plg.GInput ();
			i1.name = "Input1";
			var i2 = new Plg.GInput ();
			i1.name = "Input2";
			op.inputs.set (i1.name, i1);
			op.inputs.set (i2.name, i2);
			assert (op.inputs.size == 2);
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (i1.state);
			assert (i1.enable);
			assert (i2.state);
			assert (i2.enable);
			assert (op.get_parent () != null);
			assert (op.get_parent ().name == "Block1");
			assert (op.output.state == true);
			i1.state = false;
			assert (i1.state == false);
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == true);
			i1.state = true;
			i2.state = false;
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == true);
			i1.state = false;
			i2.state = false;
			op.evaluate ();
			assert (!op.get_evaluated ());
			assert (op.output.state == true);
		});
		Test.add_func ("/plogic/case/block-and/connected",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op = new Plg.GAnd ();
			assert (op.enable);
			assert (op.name == "AND1");
			assert (b.operators.size == 0);
			b.add_operator (op);
			assert (b.operators.size == 1);
			var i1 = new Plg.GInput ();
			i1.name = "Input1";
			var i2 = new Plg.GInput ();
			i1.name = "Input2";
			op.inputs.set (i1.name, i1);
			op.inputs.set (i2.name, i2);
			assert (op.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input2
			op.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			b.connect_output_internal ("Output1", "AND1", "Output1");
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (b.outputs.get ("Output1").state == true);
			bi1.state = false;
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (b.outputs.get ("Output1").state == false);
			bi2.state = false;
			b.evaluate ();
			assert (op.get_evaluated ());
			assert (op.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
		});
		Test.add_func ("/plogic/case/block-2and/connected",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op1 = new Plg.GAnd ();
			assert (op1.enable);
			assert (op1.name == "AND1");
			assert (b.operators.size == 0);
			b.add_operator (op1);
			assert (b.operators.size == 1);
			var i11 = new Plg.GInput ();
			i11.name = "Input1";
			var i12 = new Plg.GInput ();
			i12.name = "Input2";
			op1.inputs.set (i11.name, i11);
			op1.inputs.set (i12.name, i12);
			assert (op1.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input2
			op1.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op1.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			assert (b.connect_output_internal ("Output1", "AND1", "Output1"));
			// add second AND
			var op2 = new GAnd ();
			op2.name = "AND2";
			var i21 = new Plg.GInput ();
			i21.name = "Input1";
			var i22 = new Plg.GInput ();
			i22.name = "Input2";
			op2.inputs.set (i21.name, i21);
			op2.inputs.set (i22.name, i22);
			assert (op2.inputs.size == 2);
			op2.output.name = "Output2";
			assert (b.operators.size == 1);
			b.add_operator (op2);
			assert (b.operators.size == 2);
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b.inputs.set (bi3.name, bi3);
			assert (b.inputs.size == 3);
			assert (b.inputs.get ("Input3").state == true);
			var c4 = new GConnection ();
			c4.value = "Input3";
			op2.inputs.get ("Input2").connection = c4;
			var c5 = new GConnection ();
			c5.operator = "AND1";
			c5.value = "Output1";
			op2.inputs.get ("Input1").connection = c5;
			var c5a = new GConnection ();
			c5a.operator = "AND2";
			c5a.value = "Input1";
			op1.output.connections.add (c5a);
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b.outputs.set (bo2.name, bo2);
			assert (b.connect_output_internal ("Output2", "AND2", "Output2"));
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.inputs.get ("Input1").state);
			assert (b.inputs.get ("Input2").state);
			assert (b.inputs.get ("Input3").state);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi1.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = true;
			bi2.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == true);
			assert (b.outputs.get ("Output2").state == true);
			bi3.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
		});
		Test.add_func ("/plogic/case/block-2and-1or/connected",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op1 = new Plg.GAnd ();
			assert (op1.enable);
			assert (op1.name == "AND1");
			assert (b.operators.size == 0);
			b.add_operator (op1);
			assert (b.operators.size == 1);
			var i11 = new Plg.GInput ();
			i11.name = "Input1";
			var i12 = new Plg.GInput ();
			i12.name = "Input2";
			op1.inputs.set (i11.name, i11);
			op1.inputs.set (i12.name, i12);
			assert (op1.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input2
			op1.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op1.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			// add second AND
			var op2 = new GAnd ();
			op2.name = "AND2";
			var i21 = new Plg.GInput ();
			i21.name = "Input1";
			var i22 = new Plg.GInput ();
			i22.name = "Input2";
			op2.inputs.set (i21.name, i21);
			op2.inputs.set (i22.name, i22);
			assert (op2.inputs.size == 2);
			op2.output.name = "Output2";
			assert (b.operators.size == 1);
			b.add_operator (op2);
			assert (b.operators.size == 2);
			assert (b.connect_output_internal ("Output1", "AND1", "Output1"));
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b.inputs.set (bi3.name, bi3);
			assert (b.inputs.size == 3);
			assert (b.inputs.get ("Input3").state == true);
			var c4 = new GConnection ();
			c4.value = "Input3";
			op2.inputs.get ("Input2").connection = c4;
			var c5 = new GConnection ();
			c5.operator = "AND1";
			c5.value = "Output1";
			op2.inputs.get ("Input1").connection = c5;
			var c5a = new GConnection ();
			c5a.operator = "AND2";
			c5a.value = "Input1";
			op1.output.connections.add (c5a);
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b.outputs.set (bo2.name, bo2);
			assert (b.connect_output_internal ("Output2", "AND2", "Output2"));
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.inputs.get ("Input1").state);
			assert (b.inputs.get ("Input2").state);
			assert (b.inputs.get ("Input3").state);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi1.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = true;
			bi2.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == true);
			assert (b.outputs.get ("Output2").state == true);
			bi3.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			var bi4 = new GInput ();
			bi4.name = "Input4";
			b.inputs.set (bi4.name, bi4);
			var op3 = new GOr ();
			op3.name = "OR3";
			var i31 = new GInput ();
			var i32 = new GInput ();
			i32.name = "Input2";
			op3.inputs.set (i31.name, i31);
			op3.inputs.set (i32.name, i32);
			b.add_operator (op3);
			var c7 = new GConnection ();
			c7.operator = "AND2";
			c7.value = "Output1";
			op3.inputs.get ("Input1").connection = c7;
			var c7a = new GConnection ();
			c7a.operator = "OR3";
			c7a.value = "Input1";
			op2.output.connections.add (c7a);
			var c8 = new GConnection ();
			c8.operator = "Input4";
			op3.inputs.get ("Input2").connection = c8;
			var bo3 = new GOutput ();
			bo3.name = "Output3";
			b.outputs.set (bo3.name, bo3);
			assert (b.connect_output_internal ("Output3", "OR3", "Output1"));
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			bi4.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == true);
			assert (b.outputs.get ("Output2").state == true);
			assert (op3.get_evaluated ());
			assert (op3.output.state == true);
			assert (b.outputs.get ("Output3").state == true);
			assert (b.outputs.size == 3);
		});
		Test.add_func ("/plogic/case/block-variable",
		() => {
			var b = new Plg.GBlock ();
			assert (b.name == "Block1");
			var op1 = new Plg.GAnd ();
			assert (op1.enable);
			assert (op1.name == "AND1");
			assert (b.operators.size == 0);
			b.add_operator (op1);
			assert (b.operators.size == 1);
			var i11 = new Plg.GInput ();
			i11.name = "Input1";
			var i12 = new Plg.GInput ();
			i12.name = "Input2";
			op1.inputs.set (i11.name, i11);
			op1.inputs.set (i12.name, i12);
			assert (op1.inputs.size == 2);
			var bi1 = new Plg.GInput ();
			bi1.name = "Input1";
			b.inputs.set (bi1.name, bi1);
			assert (bi1.state == true);
			assert (bi1.enable == true);
			var bi2 = new Plg.GInput ();
			bi2.name = "Input2";
			assert (bi2.state == true);
			assert (bi2.enable == true);
			b.inputs.set (bi2.name, bi2);
			assert (b.inputs.size == 2);
			var c1 = new GConnection ();
			c1.value = "Input1"; // Block.Input1
			op1.inputs.get ("Input1").connection = c1;
			var c2 = new GConnection ();
			c2.value = "Input2"; // Block.Input2
			op1.inputs.get ("Input2").connection = c2;
			var bo1 = new Plg.GOutput ();
			assert (bo1.name == "Output1");
			b.outputs.set (bo1.name, bo1);
			assert (b.connect_output_internal ("Output1","AND1","Output1"));
			// add second AND
			var op2 = new GAnd ();
			op2.name = "AND2";
			var i21 = new Plg.GInput ();
			i21.name = "Input1";
			var i22 = new Plg.GInput ();
			i22.name = "Input2";
			op2.inputs.set (i21.name, i21);
			op2.inputs.set (i22.name, i22);
			assert (op2.inputs.size == 2);
			op2.output.name = "Output2";
			assert (b.operators.size == 1);
			b.add_operator (op2);
			assert (b.operators.size == 2);
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b.inputs.set (bi3.name, bi3);
			assert (b.inputs.size == 3);
			assert (b.inputs.get ("Input3").state == true);
			var c4 = new GConnection ();
			c4.value = "Input3"; // Block.Input3
			op2.inputs.get ("Input2").connection = c4;
			var c5 = new GConnection ();
			c5.operator = "AND1";
			c5.value = "Output1";
			op2.inputs.get ("Input1").connection = c5;
			var c5a = new GConnection ();
			c5a.operator = "AND2";
			c5a.value = "Input1";
			op1.output.connections.add (c5a);
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b.outputs.set (bo2.name, bo2);
			assert (b.connect_output_internal ("Output2", "AND2", "Output2"));
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.inputs.get ("Input1").state);
			assert (b.inputs.get ("Input2").state);
			assert (b.inputs.get ("Input3").state);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (b.outputs.get ("Output2").state == true);
			bi1.state = false;
			bi2.state = true;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.inputs.get ("Input1").connection != null);
			assert (op2.inputs.get ("Input1").connection.operator != null);
			assert (op2.inputs.get ("Input1").connection.operator == "AND1");
			assert (op2.inputs.get ("Input1").connection.value == "Output1");
			//assert_not_reached();
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = true;
			bi2.state = false;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			bi1.state = false;
			bi2.state = false;
			bi3.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			bi3.state = false;
			bi2.state = false;
			bi3.state = false;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == false);
			assert (b.outputs.get ("Output1").state == false);
			assert (op2.get_evaluated ());
			assert (op2.output.state == false);
			assert (b.outputs.get ("Output2").state == false);
			var bi4 = new GInput ();
			bi4.name = "Input4";
			b.inputs.set (bi4.name, bi4);
			var op3 = new GOr ();
			op3.name = "OR3";
			var i31 = new GInput ();
			var i32 = new GInput ();
			i32.name = "Input2";
			op3.inputs.set (i31.name, i31);
			op3.inputs.set (i32.name, i32);
			b.add_operator (op3);
			var c7 = new GConnection ();
			c7.operator = "AND2";
			c7.value = "Output1";
			op3.inputs.get ("Input1").connection = c7;
			var c7a = new GConnection ();
			c7a.operator = "OR3";
			c7a.value = "Input1";
			op2.output.connections.add (c7a);
			var c8 = new GConnection ();
			c8.operator = "Input4";
			op3.inputs.get ("Input2").connection = c8;
			var bo3 = new GOutput ();
			bo3.name = "Output3";
			b.outputs.set (bo3.name, bo3);
			assert (b.connect_output_internal ("Output3", "OR3", "Output1"));
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			bi4.state = true;
			b.evaluate ();
			assert (op1.get_evaluated ());
			assert (op1.output.state == true);
			assert (b.outputs.get ("Output1").state == true);
			assert (op2.get_evaluated ());
			assert (op2.output.state == true);
			assert (b.outputs.get ("Output2").state == true);
			assert (op3.get_evaluated ());
			assert (op3.output.state == true);
			assert (b.outputs.get ("Output3").state == true);
			assert (b.outputs.size == 3);
			// Variables
			var v1 = new GVariable ();
			v1.name = "Variable1";
			b.variables.set (v1.name, v1);
			var vc1 = new GConnection ();
			vc1.value = "Variable1";
			(b.operators.get ("AND1") as OperatorGate).output.connections.add (vc1);
			bi1.state = true;
			bi2.state = true;
			bi3.state = true;
			bi4.state = true;
			b.evaluate ();
			assert (v1.state);
			bi1.state = true;
			bi2.state = false;
			b.evaluate ();
			assert (!v1.state);
			bi1.state = false;
			bi2.state = true;
			b.evaluate ();
			assert (!v1.state);
			bi1.state = true;
			bi2.state = true;
			b.evaluate ();
			assert (v1.state);
		});
		Test.add_func ("/plogic/case/block-1and-1or/connected",
		() => {
			var b1 = new GBlock ();
			var bi1 = new GInput ();
			var bi2 = new GInput ();
			bi2.name = "Input2";
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b1.inputs.set (bi1.name, bi1);
			b1.inputs.set (bi2.name, bi2);
			b1.inputs.set (bi3.name, bi3);
			var bo1 = new GOutput ();
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b1.outputs.set (bo1.name, bo1);
			b1.outputs.set (bo2.name, bo2);
			var ao = new GAnd ();
			b1.add_operator(ao);
			var aoi1 = new GInput ();
			var aoi2 = new GInput ();
			aoi2.name = "Input2";
			ao.inputs.set (aoi1.name, aoi1);
			ao.inputs.set (aoi2.name, aoi2);
			assert (b1.connect_input_internal ("Input1","AND1","Input1"));
			assert (b1.connect_input_internal ("Input2","AND1","Input2"));
			assert (b1.connect_output_internal ("Output1", "AND1", "Output1"));
			assert (b1.operators.size == 1);
			assert (b1.operators.get ("AND1").inputs.size == 2);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").enable);
			assert (b1.operators.get ("AND1").inputs.get ("Input2") != null);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").connection != null);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").connection.operator == null);
			bi1.state = false;
			bi2.state = false;
			Test.message ("Evaluating with Just AND. Block operators = "+b1.operators.size.to_string ());
			b1.evaluate ();
			assert (b1.outputs.get ("Output1").state == false);
			bi1.state = true;
			bi2.state = true;
			b1.evaluate ();
			assert (b1.outputs.get ("Output1").state);
//			assert_not_reached ();
			var oo = new GOr ();
			b1.add_operator (oo);
			var ooi1 = new GInput ();
			var ooi2 = new GInput ();
			ooi2.name = "Input2";
			oo.inputs.set (ooi1.name, ooi1);
			oo.inputs.set (ooi2.name, ooi2);
			assert (oo.inputs.size == 2);
			assert (oo.connect_input ("Input1","AND1","Output1"));
			assert (b1.connect_input_internal ("Input3","OR1","Input2"));
			assert (b1.connect_output_internal ("Output2", "OR1", "Output1"));
			// Checks for Block1
			bi1.state = false;
			bi2.state = false;
			bi3.state = false;
			assert (b1.operators.size == 2);
			b1.evaluate ();
			assert (b1.outputs.get ("Output1").state == false);
			assert (b1.outputs.get ("Output2").state == false);
			bi1.state = false;
			bi2.state = false;
			bi3.state = true;
			assert (b1.operators.size == 2);
			b1.evaluate ();
			assert (b1.outputs.get ("Output1").state == false);
			assert (b1.outputs.get ("Output2").state == true);
		});Test.add_func ("/plogic/case/block-1or/connected",
		() => {
			var b2 = new GBlock ();
			b2.name = "Block2";
			var b2i1 = new GInput ();
			var b2i2 = new GInput ();
			b2i2.name = "Input2";
			b2.inputs.set (b2i1.name, b2i1);
			b2.inputs.set (b2i2.name, b2i2);
			var b2o1 = new GOutput ();
			b2.outputs.set (b2o1.name, b2o1);
			var b2or = new GOr ();
			b2or.name = "OR2";
			b2.add_operator (b2or);
			var b2ori1 = new GInput ();
			var b2ori2 = new GInput ();
			b2ori2.name = "Input2";
			b2or.inputs.set (b2ori1.name, b2ori1);
			b2or.inputs.set (b2ori2.name, b2ori2);
			assert (b2.connect_input_internal ("Input1", "OR2", "Input1"));
			assert (b2.connect_input_internal ("Input2", "OR2", "Input2"));
			assert (b2.connect_output_internal ("Output1", "OR2", "Output1"));
			b2i1.state = false;
			b2i2.state = false;
			b2.evaluate ();
			assert (b2.outputs.get ("Output1").state == false);
			b2i1.state = true;
			b2i2.state = true;
			b2.evaluate ();
			assert (b2.outputs.get ("Output1").state == true);
		});
		Test.add_func ("/plogic/case/block-2block-1and/connected",
		() => {
			var b1 = new GBlock ();
			var bi1 = new GInput ();
			var bi2 = new GInput ();
			bi2.name = "Input2";
			var bi3 = new GInput ();
			bi3.name = "Input3";
			b1.inputs.set (bi1.name, bi1);
			b1.inputs.set (bi2.name, bi2);
			b1.inputs.set (bi3.name, bi3);
			var bo1 = new GOutput ();
			var bo2 = new GOutput ();
			bo2.name = "Output2";
			b1.outputs.set (bo1.name, bo1);
			b1.outputs.set (bo2.name, bo2);
			var ao = new GAnd ();
			b1.add_operator(ao);
			var aoi1 = new GInput ();
			var aoi2 = new GInput ();
			aoi2.name = "Input2";
			ao.inputs.set (aoi1.name, aoi1);
			ao.inputs.set (aoi2.name, aoi2);
			assert (b1.connect_input_internal ("Input1","AND1","Input1"));
			assert (b1.connect_input_internal ("Input2","AND1","Input2"));
			assert (b1.connect_output_internal ("Output1", "AND1", "Output1"));
			assert (b1.operators.size == 1);
			assert (b1.operators.get ("AND1").inputs.size == 2);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").enable);
			assert (b1.operators.get ("AND1").inputs.get ("Input2") != null);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").connection != null);
			assert (b1.operators.get ("AND1").inputs.get ("Input2").connection.operator == null);

			var oo = new GOr ();
			b1.add_operator (oo);
			var ooi1 = new GInput ();
			var ooi2 = new GInput ();
			ooi2.name = "Input2";
			oo.inputs.set (ooi1.name, ooi1);
			oo.inputs.set (ooi2.name, ooi2);
			assert (oo.inputs.size == 2);
			assert (oo.connect_input ("Input1","AND1","Output1"));
			assert (b1.connect_input_internal ("Input3","OR1","Input2"));
			assert (b1.connect_output_internal ("Output2", "OR1", "Output1"));

			// Block2
			var b2 = new GBlock ();
			b2.name = "Block2";
			var b2i1 = new GInput ();
			var b2i2 = new GInput ();
			b2i2.name = "Input2";
			b2.inputs.set (b2i1.name, b2i1);
			b2.inputs.set (b2i2.name, b2i2);
			var b2o1 = new GOutput ();
			b2.outputs.set (b2o1.name, b2o1);
			var b2or = new GOr ();
			b2or.name = "OR2";
			b2.add_operator (b2or);
			var b2ori1 = new GInput ();
			var b2ori2 = new GInput ();
			b2ori2.name = "Input2";
			b2or.inputs.set (b2ori1.name, b2ori1);
			b2or.inputs.set (b2ori2.name, b2ori2);
			assert (b2.connect_input_internal ("Input1", "OR2", "Input1"));
			assert (b2.connect_input_internal ("Input2", "OR2", "Input2"));
			assert (b2.connect_output_internal ("Output1", "OR2", "Output1"));

			// Master block
			var mb = new GBlock ();
			mb.name = "MasterBlock";
			mb.add_operator (b1);
			mb.add_operator (b2);
			var mbi1 = new GInput ();
			var mbi2 = new GInput ();
			mbi2.name = "Input2";
			var mbi3 = new GInput ();
			mbi3.name = "Input3";
			mb.inputs.set (mbi1.name, mbi1);
			mb.inputs.set (mbi2.name, mbi2);
			mb.inputs.set (mbi3.name, mbi3);
			var mbo1 = new GOutput ();
			var mbo2 = new GOutput ();
			mbo2.name = "Output2";
			var mbo3 = new GOutput ();
			mbo3.name = "Output3";
			mb.outputs.set (mbo1.name, mbo1);
			mb.outputs.set (mbo2.name, mbo2);
			mb.outputs.set (mbo3.name, mbo3);
			assert (mb.connect_input_internal ("Input1","Block1","Input1"));
			assert (mb.connect_input_internal ("Input2","Block1","Input2"));
			assert (mb.connect_input_internal ("Input3","Block1","Input3"));
			assert (mb.connect_input_internal ("Input1","Block2","Input1"));
			assert (mb.connect_input_internal ("Input2","Block2","Input2"));
			assert (mb.connect_output_internal ("Output1","Block1","Output2"));
			assert (mb.connect_output_internal ("Output2", "Block2", "Output1"));
			assert (mb.operators.size == 2);
			assert (mb.operators.get ("Block1") != null);
			assert (mb.operators.get ("Block2") != null);

			var mand = new GAnd ();
			mand.name = "AND2";
			mb.add_operator (mand);
			var mori1 = new GInput ();
			var mori2 = new GInput ();
			mori2.name = "Input2";
			mand.inputs.set (mori1.name, mori1);
			mand.inputs.set (mori2.name, mori2);
			assert (mand.connect_input ("Input1","Block1","Output2"));
			assert (mand.connect_input ("Input2","Block2","Output1"));
			assert (mb.connect_output_internal ("Output3","AND2","Output1"));
			assert (b2.outputs.get ("Output1").connections.size == 2);

			GLib.message ("Condition 0, 0, 0");
			mbi1.state = false;
			mbi2.state = false;
			mbi3.state = false;
			//assert_not_reached ();
			mb.evaluate ();
			assert (mb.outputs.get ("Output1").state == false);
			assert (mb.outputs.get ("Output2").state == false);
			assert (mb.outputs.get ("Output3").state == false);
			//assert_not_reached ();

			GLib.message ("Condition 1, 1, 0");
			mbi1.state = true;
			mbi2.state = true;
			mbi3.state = false;
			mb.evaluate ();
			assert (mb.outputs.get ("Output1").state == true);
			assert (mb.outputs.get ("Output2").state == true);
			assert (mb.outputs.get ("Output3").state == true);
	});
	}
}
